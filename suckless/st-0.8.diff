diff a/config.def.h b/config.def.h
8c8
< static char *font = "Liberation Mono:pixelsize=12:antialias=true:autohint=true";
---
> static char *font = "Liberation Mono:pixelsize=14:antialias=true:autohint=true";
88,95c88,95
< 	"black",
< 	"red3",
< 	"green3",
< 	"yellow3",
< 	"blue2",
< 	"magenta3",
< 	"cyan3",
< 	"gray90",
---
> 	[0] = "#000000", /* black   */
> 	[1] = "#ff5555", /* red     */
> 	[2] = "#50fa7b", /* green   */
> 	[3] = "#f1fa8c", /* yellow  */
> 	[4] = "#bd93f9", /* blue    */
> 	[5] = "#ff79c6", /* magenta */
> 	[6] = "#8be9fd", /* cyan    */
> 	[7] = "#bbbbbb", /* white   */
98,111c98,109
< 	"gray50",
< 	"red",
< 	"green",
< 	"yellow",
< 	"#5c5cff",
< 	"magenta",
< 	"cyan",
< 	"white",
< 
< 	[255] = 0,
< 
< 	/* more colors can be added after 255 to use with DefaultXX */
< 	"#cccccc",
< 	"#555555",
---
> 	[8]  = "#44475a", /* black   */
> 	[9]  = "#ff5555", /* red     */
> 	[10] = "#50fa7b", /* green   */
> 	[11] = "#f1fa8c", /* yellow  */
> 	[12] = "#bd93f9", /* blue    */
> 	[13] = "#ff79c6", /* magenta */
> 	[14] = "#8be9fd", /* cyan    */
> 	[15] = "#ffffff", /* white   */
> 
> 	/* special colors */
> 	[256] = "#282a36", /* background */
> 	[257] = "#f8f8f2", /* foreground */
117c115
<  * foreground, background, cursor, reverse cursor
---
>  * foreground, background, cursor
119,121c117,119
< unsigned int defaultfg = 7;
< unsigned int defaultbg = 0;
< static unsigned int defaultcs = 256;
---
> unsigned int defaultfg = 257;
> unsigned int defaultbg = 256;
> static unsigned int defaultcs = 257;
124a123,130
>  * Colors used, when the specific fg == defaultfg. So in reverse mode this
>  * will reverse too. Another logic would only make the simple feature too
>  * complex.
>  */
> unsigned int defaultitalic = 7;
> unsigned int defaultunderline = 7;
> 
> /*
159,160c165,172
< 	{ Button4,              XK_ANY_MOD,     "\031" },
< 	{ Button5,              XK_ANY_MOD,     "\005" },
---
> 	{ Button4,              XK_NO_MOD,      "\031" },
> 	{ Button5,              XK_NO_MOD,      "\005" },
> };
> 
> MouseKey mkeys[] = {
> 	/* button               mask            function        argument */
> 	{ Button4,              XK_NO_MOD,      kscrollup,      {.i =  1} },
> 	{ Button5,              XK_NO_MOD,      kscrolldown,    {.i =  1} },
180a193,198
> 	{ MODKEY,               XK_u,           kscrollup,      {.i = -1} },
> 	{ MODKEY,               XK_d,           kscrolldown,    {.i = -1} },
> 	{ MODKEY,               XK_y,           kscrollup,      {.i = +1} },
> 	{ MODKEY,               XK_e,           kscrolldown,    {.i = +1} },
> 	{ MODKEY|ShiftMask,     XK_K,           zoom,           {.f = +1} },
> 	{ MODKEY|ShiftMask,     XK_J,           zoom,           {.f = -1} },
Only in b: config.h
Only in b: st
diff a/st.c b/st.c
50,60d49
< enum term_mode {
< 	MODE_WRAP        = 1 << 0,
< 	MODE_INSERT      = 1 << 1,
< 	MODE_ALTSCREEN   = 1 << 2,
< 	MODE_CRLF        = 1 << 3,
< 	MODE_ECHO        = 1 << 4,
< 	MODE_PRINT       = 1 << 5,
< 	MODE_UTF8        = 1 << 6,
< 	MODE_SIXEL       = 1 << 7,
< };
< 
123a113,115
> 	Line hist[HISTSIZE]; /* history buffer */
> 	int histi;    /* history index */
> 	int scr;      /* scroll back */
191,192c183,184
< static void tscrollup(int, int);
< static void tscrolldown(int, int);
---
> static void tscrollup(int, int, int);
> static void tscrolldown(int, int, int);
434c426
< 	if (term.line[y][i - 1].mode & ATTR_WRAP)
---
> 	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
437c429
< 	while (i > 0 && term.line[y][i - 1].u == ' ')
---
> 	while (i > 0 && TLINE(y)[i - 1].u == ' ')
546c538
< 		prevgp = &term.line[*y][*x];
---
> 		prevgp = &TLINE(*y)[*x];
561c553
< 				if (!(term.line[yt][xt].mode & ATTR_WRAP))
---
> 				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
568c560
< 			gp = &term.line[newy][newx];
---
> 			gp = &TLINE(newy)[newx];
589c581
< 				if (!(term.line[*y-1][term.col-1].mode
---
> 				if (!(TLINE(*y-1)[term.col-1].mode
596c588
< 				if (!(term.line[*y][term.col-1].mode
---
> 				if (!(TLINE(*y)[term.col-1].mode
627c619
< 			gp = &term.line[y][sel.nb.x];
---
> 			gp = &TLINE(y)[sel.nb.x];
630c622
< 			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
---
> 			gp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];
633c625
< 		last = &term.line[y][MIN(lastx, linelen-1)];
---
> 		last = &TLINE(y)[MIN(lastx, linelen-1)];
837a830,832
> 	if (term.scr > 0 && term.scr < HISTSIZE-1)
> 		term.scr++;
> 
844a840,842
> 	Arg arg = (Arg) { .i = term.scr };
> 
> 	kscrolldown(&arg);
1056c1054,1088
< tscrolldown(int orig, int n)
---
> kscrolldown(const Arg* a)
> {
> 	int n = a->i;
> 
> 	if (n < 0)
> 		n = term.row + n;
> 
> 	if (n > term.scr)
> 		n = term.scr;
> 
> 	if (term.scr > 0) {
> 		term.scr -= n;
> 		selscroll(0, -n);
> 		tfulldirt();
> 	}
> }
> 
> void
> kscrollup(const Arg* a)
> {
> 	int n = a->i;
> 
> 	if (n < 0)
> 		n = term.row + n;
> 
> 	if (term.scr <= HISTSIZE-n) {
> 		term.scr += n;
> 		selscroll(0, n);
> 		tfulldirt();
> 	}
> }
> 
> 
> void
> tscrolldown(int orig, int n, int copyhist)
1062a1095,1101
> 	if (copyhist) {
> 		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
> 		temp = term.hist[term.histi];
> 		term.hist[term.histi] = term.line[term.bot];
> 		term.line[term.bot] = temp;
> 	}
> 
1076c1115
< tscrollup(int orig, int n)
---
> tscrollup(int orig, int n, int copyhist)
1082a1122,1128
> 	if (copyhist) {
> 		term.histi = (term.histi + 1) % HISTSIZE;
> 		temp = term.hist[term.histi];
> 		term.hist[term.histi] = term.line[orig];
> 		term.line[orig] = temp;
> 	}
> 
1131c1177
< 		tscrollup(term.top, 1);
---
> 		tscrollup(term.top, 1, 1);
1296c1342
< 		tscrolldown(term.c.y, n);
---
> 		tscrolldown(term.c.y, n, 0);
1303c1349
< 		tscrollup(term.c.y, n);
---
> 		tscrollup(term.c.y, n, 0);
1732c1778
< 		tscrollup(term.top, csiescseq.arg[0]);
---
> 		tscrollup(term.top, csiescseq.arg[0], 0);
1736c1782
< 		tscrolldown(term.top, csiescseq.arg[0]);
---
> 		tscrolldown(term.top, csiescseq.arg[0], 0);
2260c2306
< 			tscrollup(term.top, 1);
---
> 			tscrollup(term.top, 1, 1);
2273c2319
< 			tscrolldown(term.top, 1);
---
> 			tscrolldown(term.top, 1, 1);
2492c2538
< 	int i;
---
> 	int i, j;
2529c2575,2583
< 	/* resize each row to new width, zero-pad if needed */
---
> 	for (i = 0; i < HISTSIZE; i++) {
> 		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
> 		for (j = mincol; j < col; j++) {
> 			term.hist[i][j] = term.c.attr;
> 			term.hist[i][j].u = ' ';
> 		}
> 	}
> 
> 	/* resize each r w to new width, zero-pad if needed */
2586c2640
< 		xdrawline(term.line[y], x1, y, x2);
---
> 		xdrawline(TLINE(y), x1, y, x2);
2607,2608c2661,2664
< 	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
< 			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
---
> 	if (term.scr == 0) {
> 		xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
> 				term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
> 	}
Only in b: st.c.orig
diff a/st.h b/st.h
5a6,8
> /* Arbitrary size */
> #define HISTSIZE      2000
> 
21a25,37
> #define TLINE(y)       ((y) < term.scr ? term.hist[((y) + term.histi - term.scr \
>                + HISTSIZE + 1) % HISTSIZE] : term.line[(y) - term.scr])
> 
> enum term_mode {
> 	MODE_WRAP        = 1 << 0,
> 	MODE_INSERT      = 1 << 1,
> 	MODE_ALTSCREEN   = 1 << 2,
> 	MODE_CRLF        = 1 << 3,
> 	MODE_ECHO        = 1 << 4,
> 	MODE_PRINT       = 1 << 5,
> 	MODE_UTF8        = 1 << 6,
> 	MODE_SIXEL       = 1 << 7,
> };
78a95,101
> typedef struct {
> 	uint b;
> 	uint mask;
> 	void (*func)(const Arg *);
> 	const Arg arg;
> } MouseKey;
> 
113a137,139
> void kscrolldown(const Arg *);
> void kscrollup(const Arg *);
> 
123a150
> extern MouseKey mkeys[];
Only in b: st.o
diff a/x.c b/x.c
411a412
> 	MouseKey *mk;
419,422c420,432
< 	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
< 		if (e->xbutton.button == ms->b
< 				&& match(ms->mask, e->xbutton.state)) {
< 			ttywrite(ms->s, strlen(ms->s), 1);
---
> 	if (IS_SET(MODE_ALTSCREEN))
> 		for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
> 			if (e->xbutton.button == ms->b
> 					&& match(ms->mask, e->xbutton.state)) {
> 				ttywrite(ms->s, strlen(ms->s), 1);
> 				return;
> 			}
> 		}
> 
> 	for (mk = mkeys; mk < mkeys + LEN(mkeys); mk++) {
> 		if (e->xbutton.button == mk->b
> 				&& match(mk->mask, e->xbutton.state)) {
> 			mk->func(&mk->arg);
Only in b: x.o
